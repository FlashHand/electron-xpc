{"version":3,"sources":["../../src/renderer/xpcRenderer.helper.ts","../../src/shared/xpcHandler.type.ts","../../src/renderer/xpcRenderer.handler.ts","../../src/renderer/xpcRenderer.emitter.ts"],"names":[],"mappings":";AAMO,IAAM,cAAe,UAAA,CAAmB;;;ACFxC,IAAM,kBAAA,GAAqB,MAAA;AAM3B,IAAM,eAAA,GAAkB,CAAC,SAAA,EAAmB,UAAA,KAA+B;AAChF,EAAA,OAAO,CAAA,EAAG,kBAAkB,CAAA,EAAG,SAAS,IAAI,UAAU,CAAA,CAAA;AACxD,CAAA;AAKO,IAAM,qBAAA,GAAwB,CAAC,SAAA,KAAgC;AACpE,EAAA,MAAM,QAAkB,EAAC;AACzB,EAAA,MAAM,IAAA,GAAO,MAAA,CAAO,mBAAA,CAAoB,SAAS,CAAA;AACjD,EAAA,KAAA,MAAW,OAAO,IAAA,EAAM;AACtB,IAAA,IAAI,QAAQ,aAAA,EAAe;AAC3B,IAAA,MAAM,UAAA,GAAa,MAAA,CAAO,wBAAA,CAAyB,SAAA,EAAW,GAAG,CAAA;AACjE,IAAA,IAAI,UAAA,IAAc,OAAO,UAAA,CAAW,KAAA,KAAU,UAAA,EAAY;AACxD,MAAA,KAAA,CAAM,KAAK,GAAG,CAAA;AAAA,IAChB;AAAA,EACF;AACA,EAAA,OAAO,KAAA;AACT,CAAA;;;ACVO,IAAM,qBAAN,MAAyB;AAAA,EAC9B,WAAA,GAAc;AACZ,IAAA,MAAM,SAAA,GAAY,KAAK,WAAA,CAAY,IAAA;AACnC,IAAA,MAAM,WAAA,GAAc,qBAAA,CAAsB,MAAA,CAAO,cAAA,CAAe,IAAI,CAAC,CAAA;AACrE,IAAA,KAAA,MAAW,cAAc,WAAA,EAAa;AACpC,MAAA,MAAM,OAAA,GAAU,eAAA,CAAgB,SAAA,EAAW,UAAU,CAAA;AACrD,MAAA,MAAM,MAAA,GAAU,IAAA,CAAa,UAAU,CAAA,CAAE,KAAK,IAAI,CAAA;AAClD,MAAA,WAAA,CAAY,MAAA,CAAO,OAAA,EAAS,OAAO,OAAA,KAAwB;AACzD,QAAA,OAAO,MAAM,MAAA,CAAO,OAAA,CAAQ,MAAM,CAAA;AAAA,MACpC,CAAC,CAAA;AAAA,IACH;AAAA,EACF;AACF;;;ACZO,IAAM,wBAAA,GAA2B,CAAI,SAAA,KAAuC;AACjF,EAAA,OAAO,IAAI,KAAA,CAAM,EAAC,EAAsB;AAAA,IACtC,GAAA,CAAI,SAAS,IAAA,EAAc;AACzB,MAAA,MAAM,OAAA,GAAU,eAAA,CAAgB,SAAA,EAAW,IAAI,CAAA;AAC/C,MAAA,OAAO,CAAC,MAAA,KAAiB,WAAA,CAAY,IAAA,CAAK,SAAS,MAAM,CAAA;AAAA,IAC3D;AAAA,GACD,CAAA;AACH","file":"index.mjs","sourcesContent":["import type { XpcRendererApi } from '../shared/xpc.type';\n\n/**\n * Direct reference to window.xpcRenderer exposed by the preload script.\n * Import this in renderer (browser) code to use xpcRenderer without manual window casting.\n */\nexport const xpcRenderer = (globalThis as any).xpcRenderer as XpcRendererApi;\n\nexport type { XpcRendererApi, XpcPayload } from '../shared/xpc.type';\n","/**\n * Prefix for all auto-registered xpc handler channels.\n * Channel format: `xpc:ClassName/methodName`\n */\nexport const XPC_HANDLER_PREFIX = 'xpc:';\n\n/**\n * Build the xpc channel name from class name and method name.\n * e.g. buildChannel('UserTable', 'getUserList') => 'xpc:UserTable/getUserList'\n */\nexport const buildXpcChannel = (className: string, methodName: string): string => {\n  return `${XPC_HANDLER_PREFIX}${className}/${methodName}`;\n};\n\n/**\n * Extract own method names from a class prototype, excluding constructor.\n */\nexport const getHandlerMethodNames = (prototype: object): string[] => {\n  const names: string[] = [];\n  const keys = Object.getOwnPropertyNames(prototype);\n  for (const key of keys) {\n    if (key === 'constructor') continue;\n    const descriptor = Object.getOwnPropertyDescriptor(prototype, key);\n    if (descriptor && typeof descriptor.value === 'function') {\n      names.push(key);\n    }\n  }\n  return names;\n};\n\n/**\n * Constraint: handler methods must accept 0 or 1 parameter.\n * Methods with 2+ parameters will fail type checking.\n */\nexport type XpcHandlerMethod = (() => Promise<any>) | ((params: any) => Promise<any>);\n\n/**\n * Helper: checks if a function type has at most 1 parameter.\n * Returns the function type itself if valid, `never` otherwise.\n * Uses Parameters<> length check to avoid contravariance issues\n * where (p: any) => any extends () => any in TypeScript.\n */\ntype AssertSingleParam<F> =\n  F extends (...args: any[]) => any\n    ? Parameters<F>['length'] extends 0 | 1 ? F : never\n    : never;\n\n/**\n * Utility type: extracts the method signatures from a handler class,\n * turning each method into an emitter-compatible signature.\n * Methods with 2+ parameters are mapped to `never`, causing a compile error on use.\n */\nexport type XpcEmitterOf<T> = {\n  [K in keyof T as T[K] extends (...args: any[]) => any ? K : never]:\n    AssertSingleParam<T[K]> extends never\n      ? never\n      : T[K] extends (params: infer P) => any\n        ? Parameters<T[K]>['length'] extends 0\n          ? () => Promise<any>\n          : (params: P) => Promise<any>\n        : () => Promise<any>;\n};\n","import { XpcPayload } from '../shared/xpc.type';\nimport { buildXpcChannel, getHandlerMethodNames } from '../shared/xpcHandler.type';\nimport { xpcRenderer } from './xpcRenderer.helper';\n\n/**\n * Base class for renderer-process xpc handlers.\n * Subclass this and define async methods â€” they will be auto-registered\n * as xpc handlers with channel `xpc:ClassName/methodName`.\n *\n * Example:\n * ```ts\n * class UserTable extends XpcRendererHandler {\n *   async getUserList(params?: any): Promise<any> { ... }\n * }\n * const userTable = new UserTable();\n * // auto-registers handler for 'xpc:UserTable/getUserList'\n * ```\n */\nexport class XpcRendererHandler {\n  constructor() {\n    const className = this.constructor.name;\n    const methodNames = getHandlerMethodNames(Object.getPrototypeOf(this));\n    for (const methodName of methodNames) {\n      const channel = buildXpcChannel(className, methodName);\n      const method = (this as any)[methodName].bind(this);\n      xpcRenderer.handle(channel, async (payload: XpcPayload) => {\n        return await method(payload.params);\n      });\n    }\n  }\n}\n","import { buildXpcChannel, XpcEmitterOf } from '../shared/xpcHandler.type';\nimport { xpcRenderer } from './xpcRenderer.helper';\n\n/**\n * Create a type-safe emitter proxy for a renderer-process xpc handler.\n * The emitter mirrors the handler's method signatures, but each call\n * sends a message via xpcRenderer.send() to `xpc:ClassName/methodName`.\n *\n * Example:\n * ```ts\n * class UserTable extends XpcRendererHandler {\n *   async getUserList(params?: any): Promise<any> { ... }\n * }\n * const userTableEmitter = createXpcRendererEmitter<UserTable>('UserTable');\n * const list = await userTableEmitter.getUserList({ page: 1 });\n * // sends to 'xpc:UserTable/getUserList'\n * ```\n */\nexport const createXpcRendererEmitter = <T>(className: string): XpcEmitterOf<T> => {\n  return new Proxy({} as XpcEmitterOf<T>, {\n    get(_target, prop: string) {\n      const channel = buildXpcChannel(className, prop);\n      return (params?: any) => xpcRenderer.send(channel, params);\n    },\n  });\n};\n"]}