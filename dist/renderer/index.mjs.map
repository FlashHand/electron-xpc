{"version":3,"sources":["../../src/renderer/xpcRenderer.helper.ts","../../src/shared/xpc.decorator.ts","../../src/shared/xpcHandler.type.ts","../../src/renderer/xpcRenderer.handler.ts","../../src/renderer/xpcRenderer.emitter.ts"],"names":[],"mappings":";AAMO,IAAM,cAAe,UAAA,CAAmB;;;ACHxC,IAAM,UAAA,0BAAoB,YAAY,CAAA;AAetC,IAAM,SAAA,GAAY,CAAC,MAAA,EAAa,WAAA,KAA8B;AACnE,EAAA,MAAM,UAAA,GAAa,MAAA,CAAO,wBAAA,CAAyB,MAAA,EAAQ,WAAW,CAAA;AACtE,EAAA,IAAI,UAAA,IAAc,OAAO,UAAA,CAAW,KAAA,KAAU,UAAA,EAAY;AACxD,IAAA,UAAA,CAAW,KAAA,CAAM,UAAU,CAAA,GAAI,IAAA;AAAA,EACjC;AACF;;;ACjBO,IAAM,kBAAA,GAAqB,MAAA;AAM3B,IAAM,eAAA,GAAkB,CAAC,SAAA,EAAmB,UAAA,KAA+B;AAChF,EAAA,OAAO,CAAA,EAAG,kBAAkB,CAAA,EAAG,SAAS,IAAI,UAAU,CAAA,CAAA;AACxD,CAAA;AASO,IAAM,qBAAA,GAAwB,CAAC,SAAA,KAAgC;AACpE,EAAA,MAAM,QAAkB,EAAC;AACzB,EAAA,MAAM,IAAA,GAAO,MAAA,CAAO,mBAAA,CAAoB,SAAS,CAAA;AACjD,EAAA,KAAA,MAAW,OAAO,IAAA,EAAM;AACtB,IAAA,IAAI,QAAQ,aAAA,EAAe;AAG3B,IAAA,IAAI,IAAI,UAAA,CAAW,GAAG,KAAK,GAAA,CAAI,UAAA,CAAW,GAAG,CAAA,EAAG;AAEhD,IAAA,MAAM,UAAA,GAAa,MAAA,CAAO,wBAAA,CAAyB,SAAA,EAAW,GAAG,CAAA;AACjE,IAAA,IAAI,UAAA,IAAc,OAAO,UAAA,CAAW,KAAA,KAAU,UAAA,EAAY;AAExD,MAAA,IAAI,UAAA,CAAW,KAAA,CAAM,UAAU,CAAA,EAAG;AAElC,MAAA,KAAA,CAAM,KAAK,GAAG,CAAA;AAAA,IAChB;AAAA,EACF;AACA,EAAA,OAAO,KAAA;AACT,CAAA;;;ACTO,IAAM,qBAAN,MAAyB;AAAA,EAC9B,WAAA,GAAc;AACZ,IAAA,MAAM,SAAA,GAAY,KAAK,WAAA,CAAY,IAAA;AACnC,IAAA,MAAM,WAAA,GAAc,qBAAA,CAAsB,MAAA,CAAO,cAAA,CAAe,IAAI,CAAC,CAAA;AACrE,IAAA,KAAA,MAAW,cAAc,WAAA,EAAa;AACpC,MAAA,MAAM,OAAA,GAAU,eAAA,CAAgB,SAAA,EAAW,UAAU,CAAA;AACrD,MAAA,MAAM,MAAA,GAAU,IAAA,CAAa,UAAU,CAAA,CAAE,KAAK,IAAI,CAAA;AAClD,MAAA,WAAA,CAAY,MAAA,CAAO,OAAA,EAAS,OAAO,OAAA,KAAwB;AACzD,QAAA,OAAO,MAAM,MAAA,CAAO,OAAA,CAAQ,MAAM,CAAA;AAAA,MACpC,CAAC,CAAA;AAAA,IACH;AAAA,EACF;AACF;;;ACnBO,IAAM,wBAAA,GAA2B,CAAI,SAAA,KAAuC;AACjF,EAAA,OAAO,IAAI,KAAA,CAAM,EAAC,EAAsB;AAAA,IACtC,GAAA,CAAI,SAAS,IAAA,EAAc;AACzB,MAAA,MAAM,OAAA,GAAU,eAAA,CAAgB,SAAA,EAAW,IAAI,CAAA;AAC/C,MAAA,OAAO,CAAC,MAAA,KAAiB,WAAA,CAAY,IAAA,CAAK,SAAS,MAAM,CAAA;AAAA,IAC3D;AAAA,GACD,CAAA;AACH","file":"index.mjs","sourcesContent":["import type { XpcRendererApi } from '../shared/xpc.type';\n\n/**\n * Direct reference to window.xpcRenderer exposed by the preload script.\n * Import this in renderer (browser) code to use xpcRenderer without manual window casting.\n */\nexport const xpcRenderer = (globalThis as any).xpcRenderer as XpcRendererApi;\n\nexport type { XpcRendererApi, XpcPayload } from '../shared/xpc.type';\n","/**\n * Symbol to mark methods that should not be auto-registered as xpc handlers.\n */\nexport const XPC_IGNORE = Symbol('xpc:ignore');\n\n/**\n * Decorator to mark a method as ignored for xpc handler auto-registration.\n * \n * Usage:\n * ```ts\n * class UserService extends XpcMainHandler {\n *   async getUserList(): Promise<any> { ... } // will be registered\n *   \n *   @xpcIgnore\n *   async helperMethod(): Promise<void> { ... } // will NOT be registered\n * }\n * ```\n */\nexport const xpcIgnore = (target: any, propertyKey: string): void => {\n  const descriptor = Object.getOwnPropertyDescriptor(target, propertyKey);\n  if (descriptor && typeof descriptor.value === 'function') {\n    descriptor.value[XPC_IGNORE] = true;\n  }\n};\n","import { XPC_IGNORE } from './xpc.decorator';\n\n/**\n * Prefix for all auto-registered xpc handler channels.\n * Channel format: `xpc:ClassName/methodName`\n */\nexport const XPC_HANDLER_PREFIX = 'xpc:';\n\n/**\n * Build the xpc channel name from class name and method name.\n * e.g. buildChannel('UserTable', 'getUserList') => 'xpc:UserTable/getUserList'\n */\nexport const buildXpcChannel = (className: string, methodName: string): string => {\n  return `${XPC_HANDLER_PREFIX}${className}/${methodName}`;\n};\n\n/**\n * Extract own method names from a class prototype, excluding constructor.\n * \n * Methods are ignored if:\n * 1. Name starts with `_` or `$` (private method convention)\n * 2. Marked with @xpcIgnore decorator\n */\nexport const getHandlerMethodNames = (prototype: object): string[] => {\n  const names: string[] = [];\n  const keys = Object.getOwnPropertyNames(prototype);\n  for (const key of keys) {\n    if (key === 'constructor') continue;\n    \n    // Skip methods starting with _ or $\n    if (key.startsWith('_') || key.startsWith('$')) continue;\n    \n    const descriptor = Object.getOwnPropertyDescriptor(prototype, key);\n    if (descriptor && typeof descriptor.value === 'function') {\n      // Skip methods marked with @xpcIgnore\n      if (descriptor.value[XPC_IGNORE]) continue;\n      \n      names.push(key);\n    }\n  }\n  return names;\n};\n\n/**\n * Constraint: handler methods must accept 0 or 1 parameter.\n * Methods with 2+ parameters will fail type checking.\n */\nexport type XpcHandlerMethod = (() => Promise<any>) | ((params: any) => Promise<any>);\n\n/**\n * Helper: checks if a function type has at most 1 parameter.\n * Returns the function type itself if valid, `never` otherwise.\n * Uses Parameters<> length check to avoid contravariance issues\n * where (p: any) => any extends () => any in TypeScript.\n */\ntype AssertSingleParam<F> =\n  F extends (...args: any[]) => any\n    ? Parameters<F>['length'] extends 0 | 1 ? F : never\n    : never;\n\n/**\n * Filters out keys that start with `_` or `$` (private method convention).\n */\ntype ExcludePrivateKeys<K> = K extends `_${string}` | `$${string}` ? never : K;\n\n/**\n * Utility type: extracts the method signatures from a handler class,\n * turning each method into an emitter-compatible signature.\n * Methods with 2+ parameters are mapped to `never`, causing a compile error on use.\n * Methods with `_` or `$` prefix are excluded from the emitter type.\n * Methods marked with @xpcIgnore are excluded at runtime; use `_`/`$` prefix\n * to also exclude them from the type-level emitter.\n */\nexport type XpcEmitterOf<T> = {\n  [K in keyof T as T[K] extends (...args: any[]) => any ? ExcludePrivateKeys<K> : never]:\n    AssertSingleParam<T[K]> extends never\n      ? never\n      : T[K] extends (params: infer P) => any\n        ? Parameters<T[K]>['length'] extends 0\n          ? () => Promise<any>\n          : (params: P) => Promise<any>\n        : () => Promise<any>;\n};\n","import { XpcPayload } from '../shared/xpc.type';\nimport { buildXpcChannel, getHandlerMethodNames } from '../shared/xpcHandler.type';\nimport { xpcRenderer } from './xpcRenderer.helper';\n\n/**\n * Base class for renderer-process xpc handlers.\n * Subclass this and define async methods — they will be auto-registered\n * as xpc handlers with channel `xpc:ClassName/methodName`.\n *\n * Methods are ignored if:\n * 1. Name starts with `_` or `$` (private method convention)\n * 2. Marked with @xpcIgnore decorator\n *\n * Example:\n * ```ts\n * // In renderer process — register handler:\n * class UINotification extends XpcRendererHandler {\n *   async showToast(params?: any): Promise<void> { ... } // registered\n *   \n *   async _helperMethod(): Promise<void> { ... } // NOT registered\n *   \n *   @xpcIgnore\n *   async internalMethod(): Promise<void> { ... } // NOT registered\n * }\n * const uiNotification = new UINotification();\n *\n * // In preload process — call via emitter:\n * import type { UINotification } from '@renderer/uiNotification.handler';\n * const emitter = createXpcPreloadEmitter<UINotification>('UINotification');\n * await emitter.showToast({ text: 'Hello!' });\n * ```\n */\nexport class XpcRendererHandler {\n  constructor() {\n    const className = this.constructor.name;\n    const methodNames = getHandlerMethodNames(Object.getPrototypeOf(this));\n    for (const methodName of methodNames) {\n      const channel = buildXpcChannel(className, methodName);\n      const method = (this as any)[methodName].bind(this);\n      xpcRenderer.handle(channel, async (payload: XpcPayload) => {\n        return await method(payload.params);\n      });\n    }\n  }\n}\n","import { buildXpcChannel, XpcEmitterOf } from '../shared/xpcHandler.type';\nimport { xpcRenderer } from './xpcRenderer.helper';\n\n/**\n * Create a type-safe emitter proxy for a renderer-process xpc handler.\n * The emitter mirrors the handler's method signatures, but each call\n * sends a message via xpcRenderer.send() to `xpc:ClassName/methodName`.\n *\n * CRITICAL: Always use `import type` to avoid importing actual handler implementation\n * and its dependencies (e.g., node-only modules) into the renderer process.\n *\n * Example:\n * ```ts\n * // In main process:\n * class UserTable extends XpcMainHandler {\n *   async getUserList(params?: any): Promise<any> { ... }\n * }\n *\n * // In renderer process:\n * import type { UserTable } from '@main/userTable.handler'; // ← type-only import!\n * const userTableEmitter = createXpcRendererEmitter<UserTable>('UserTable');\n * const list = await userTableEmitter.getUserList({ page: 1 });\n * // sends to 'xpc:UserTable/getUserList'\n * ```\n */\nexport const createXpcRendererEmitter = <T>(className: string): XpcEmitterOf<T> => {\n  return new Proxy({} as XpcEmitterOf<T>, {\n    get(_target, prop: string) {\n      const channel = buildXpcChannel(className, prop);\n      return (params?: any) => xpcRenderer.send(channel, params);\n    },\n  }) as XpcEmitterOf<T>;\n};\n"]}