{"version":3,"sources":["../../main/xpc-task.helper.ts","../../main/xpc-center.helper.ts","../../main/xpc-id.helper.ts","../../main/xpc-main.helper.ts"],"names":["Semaphore","ipcMain","webContents","XPC_FINISH"],"mappings":"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","file":"index.js","sourcesContent":["import { Semaphore } from 'rig-foundation';\nimport { XpcPayload } from '../shared/xpc.type';\n\nexport class XpcTask implements XpcPayload {\n  id: string;\n  handleName: string;\n  params?: any;\n  ret?: any;\n\n  private semaphore: Semaphore;\n\n  constructor(payload: XpcPayload) {\n    this.id = payload.id;\n    this.handleName = payload.handleName;\n    this.params = payload.params;\n    this.ret = payload.ret ?? null;\n    this.semaphore = new Semaphore(1);\n    this.semaphore.take(() => {});\n  }\n\n  /** Block until unblock() is called */\n  block(): Promise<void> {\n    return this.semaphore.takeAsync();\n  }\n\n  /** Release the semaphore, unblocking the waiting block() call */\n  unblock(): void {\n    this.semaphore.leave();\n  }\n\n  /** Convert to a plain XpcPayload (serializable for IPC) */\n  toPayload(): XpcPayload {\n    return {\n      id: this.id,\n      handleName: this.handleName,\n      params: this.params,\n      ret: this.ret,\n    };\n  }\n}\n","import { ipcMain, webContents } from 'electron';\nimport { XpcPayload } from '../shared/xpc.type';\nimport { XpcTask } from './xpc-task.helper';\n\nconst XPC_REGISTER = '__xpc_register__';\nconst XPC_EXEC = '__xpc_exec__';\nconst XPC_FINISH = '__xpc_finish__';\n\n/**\n * XpcCenter: runs in the main process.\n * - Listens for __xpc_register__: renderer registers a handleName, center stores {handleName → webContentsId}\n * - Listens for __xpc_exec__ (ipcMain.handle): renderer invokes exec, center forwards to target renderer,\n *   blocks via semaphore until __xpc_finish__ is received, then returns result.\n * - Listens for __xpc_finish__: target renderer finished execution, unblocks the pending task.\n */\nclass XpcCenter {\n  /** handleName → webContentsId */\n  private registry = new Map<string, number>();\n  /** task.id → XpcTask (with semaphore block/unblock) */\n  private pendingTasks = new Map<string, XpcTask>();\n\n  constructor() {\n    this.setupListeners();\n  }\n\n  private setupListeners(): void {\n    // Renderer registers a handleName\n    ipcMain.on(XPC_REGISTER, (event, payload: { handleName: string }) => {\n      this.registry.set(payload.handleName, event.sender.id);\n    });\n\n    // Renderer invokes exec: forward to target renderer, block until finish\n    ipcMain.handle(XPC_EXEC, async (_event, payload: XpcPayload): Promise<any> => {\n      const targetId = this.registry.get(payload.handleName);\n      if (targetId == null) {\n        return null;\n      }\n\n      const target = webContents.fromId(targetId);\n      if (!target) {\n        return null;\n      }\n\n      // Create semaphore-blocked task\n      const task = new XpcTask(payload);\n\n      this.pendingTasks.set(task.id, task);\n\n      // Forward handleName event + payload to target renderer\n      target.send(payload.handleName, payload);\n\n      // Block until __xpc_finish__ unblocks\n      await task.block();\n      this.pendingTasks.delete(task.id);\n\n      return task.toPayload().ret ?? null;\n    });\n\n    // Target renderer finished execution, unblock pending task\n    ipcMain.on(XPC_FINISH, (_event, payload: XpcPayload) => {\n      const task = this.pendingTasks.get(payload.id);\n      if (task) {\n        task.ret = payload.ret ?? null;\n        task.unblock();\n      }\n    });\n  }\n}\n\nexport const xpcCenter = new XpcCenter();\n","/**\n * High-performance process-unique ID generator.\n * Combines a random prefix (per process) with an incrementing counter.\n * Guaranteed unique within a single process lifetime.\n */\nconst prefix = Math.random().toString(36).slice(2, 8);\nlet counter = 0;\n\nexport const generateXpcId = (): string => {\n  return `${prefix}-${(++counter).toString(36)}`;\n};\n","import { BrowserWindow, ipcMain } from 'electron';\nimport { XpcPayload } from '../shared/xpc.type';\nimport { XpcTask } from './xpc-task.helper';\nimport { generateXpcId } from './xpc-id.helper';\n\nconst XPC_FINISH = '__xpc_finish__';\n\n/**\n * XpcMain: runs in the main process.\n * Sends messages to a specific renderer window and awaits the response.\n * Uses Semaphore to block until __xpc_finish__ is received from the target renderer.\n */\nclass XpcMain {\n  private pendingTasks = new Map<string, XpcTask>();\n\n  constructor() {\n    this.setupFinishListener();\n  }\n\n  private setupFinishListener(): void {\n    ipcMain.on(XPC_FINISH, (_event, payload: XpcPayload) => {\n      const task = this.pendingTasks.get(payload.id);\n      if (task) {\n        task.ret = payload.ret ?? null;\n        task.unblock();\n      }\n    });\n  }\n\n  /**\n   * Send a message to a specific renderer window and await the response.\n   * The target renderer must have registered the handleName via xpcRenderer.handle().\n   */\n  async sendToRenderer(\n    win: BrowserWindow,\n    handleName: string,\n    params?: any\n  ): Promise<any> {\n    const task = new XpcTask({\n      id: generateXpcId(),\n      handleName,\n      params,\n    });\n\n    this.pendingTasks.set(task.id, task);\n\n    // Send handleName event + payload to target renderer\n    win.webContents.send(handleName, task.toPayload());\n\n    // Block until __xpc_finish__\n    await task.block();\n    this.pendingTasks.delete(task.id);\n\n    return task.toPayload().ret ?? null;\n  }\n}\n\nexport const xpcMain = new XpcMain();\n"]}