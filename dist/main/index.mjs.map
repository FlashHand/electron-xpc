{"version":3,"sources":["../../src/main/xpcTask.helper.ts","../../src/main/xpcId.helper.ts","../../src/main/xpcMain.helper.ts","../../src/main/xpcCenter.helper.ts","../../src/shared/xpc.decorator.ts","../../src/shared/xpcHandler.type.ts","../../src/main/xpcMain.handler.ts","../../src/main/xpcMain.emitter.ts"],"names":[],"mappings":"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","file":"index.mjs","sourcesContent":["import { Semaphore } from 'rig-foundation';\nimport { XpcPayload } from '../shared/xpc.type';\n\nexport class XpcTask implements XpcPayload {\n  id: string;\n  handleName: string;\n  params?: any;\n  ret?: any;\n\n  private semaphore: Semaphore;\n\n  constructor(payload: XpcPayload) {\n    this.id = payload.id;\n    this.handleName = payload.handleName;\n    this.params = payload.params;\n    this.ret = payload.ret ?? null;\n    this.semaphore = new Semaphore(1);\n    this.semaphore.take(() => {});\n  }\n\n  /** Block until unblock() is called */\n  block(): Promise<void> {\n    return this.semaphore.takeAsync();\n  }\n\n  /** Release the semaphore, unblocking the waiting block() call */\n  unblock(): void {\n    this.semaphore.leave();\n  }\n\n  /** Convert to a plain XpcPayload (serializable for IPC) */\n  toPayload(): XpcPayload {\n    return {\n      id: this.id,\n      handleName: this.handleName,\n      params: this.params,\n      ret: this.ret,\n    };\n  }\n}\n","/**\n * High-performance process-unique ID generator.\n * Combines a random prefix (per process) with an incrementing counter.\n * Guaranteed unique within a single process lifetime.\n */\nconst prefix = Math.random().toString(36).slice(2, 8);\nlet counter = 0;\n\nexport const generateXpcId = (): string => {\n  return `${prefix}-${(++counter).toString(36)}`;\n};\n","import { XpcPayload } from '../shared/xpc.type';\nimport { xpcCenter } from './xpcCenter.helper';\n\ntype XpcHandler = (payload: XpcPayload) => Promise<any>;\n\n/**\n * XpcMain: runs in the main process.\n * - handle(): register a handler callable by renderers or other main-process code.\n * - send(): invoke a registered handleName (main-process or renderer), delegating to xpcCenter.\n */\nclass XpcMain {\n  private handlers = new Map<string, XpcHandler>();\n\n  /**\n   * Register a handler in the main process.\n   * When another renderer calls send() with this handleName, xpcCenter will\n   * invoke this handler directly (webContentsId = 0) without forwarding to a renderer.\n   */\n  handle(handleName: string, handler: XpcHandler): void {\n    this.handlers.set(handleName, handler);\n    xpcCenter.registerMainHandler(handleName);\n  }\n\n  /**\n   * Get the registered handler for a given handleName.\n   */\n  getHandler(handleName: string): XpcHandler | undefined {\n    return this.handlers.get(handleName);\n  }\n\n  /**\n   * Send a message to a registered handler by handleName.\n   * Delegates to xpcCenter.exec() which handles both main-process and renderer targets.\n   */\n  async send(handleName: string, params?: any): Promise<any> {\n    return xpcCenter.exec(handleName, params);\n  }\n}\n\nexport const xpcMain = new XpcMain();\n","import { ipcMain, webContents } from 'electron';\nimport { XpcPayload } from '../shared/xpc.type';\nimport { XpcTask } from './xpcTask.helper';\nimport { generateXpcId } from './xpcId.helper';\nimport { xpcMain } from './xpcMain.helper';\n\nconst XPC_REGISTER = '__xpc_register__';\nconst XPC_EXEC = '__xpc_exec__';\nconst XPC_FINISH = '__xpc_finish__';\n\n/**\n * XpcCenter: runs in the main process.\n * - Listens for __xpc_register__: renderer registers a handleName, center stores {handleName → webContentsId}\n * - Listens for __xpc_exec__ (ipcMain.handle): renderer invokes exec, center forwards to target renderer,\n *   blocks via semaphore until __xpc_finish__ is received, then returns result.\n * - Listens for __xpc_finish__: target renderer finished execution, unblocks the pending task.\n */\nclass XpcCenter {\n  /** handleName → webContentsId */\n  private registry = new Map<string, number>();\n  /** task.id → XpcTask (with semaphore block/unblock) */\n  private pendingTasks = new Map<string, XpcTask>();\n\n  init(): void {\n    this.setupListeners();\n  }\n\n  /**\n   * Register a main-process handleName in the registry with webContentsId = 0.\n   */\n  registerMainHandler(handleName: string): void {\n    this.registry.set(handleName, 0);\n  }\n\n  /**\n   * Execute a handleName: if main-process handler, call directly;\n   * otherwise forward to target renderer, block until __xpc_finish__.\n   * Used by both ipcMain.handle(XPC_EXEC) and xpcMain.send().\n   */\n  async exec(handleName: string, params?: any): Promise<any> {\n    const targetId = this.registry.get(handleName);\n    if (targetId == null) {\n      return null;\n    }\n\n    const payload: XpcPayload = {\n      id: generateXpcId(),\n      handleName,\n      params,\n    };\n\n    // targetId === 0 means the handler is registered in the main process\n    if (targetId === 0) {\n      const handler = xpcMain.getHandler(handleName);\n      if (!handler) {\n        return null;\n      }\n      try {\n        return await handler(payload);\n      } catch (_e) {\n        return null;\n      }\n    }\n\n    const target = webContents.fromId(targetId);\n    if (!target || target.isDestroyed() || target.isCrashed()) {\n      return null;\n    }\n\n    // Create semaphore-blocked task\n    const task = new XpcTask(payload);\n\n    this.pendingTasks.set(task.id, task);\n\n    // Forward handleName event + payload to target renderer\n    target.send(handleName, payload);\n\n    // Block until __xpc_finish__ unblocks\n    await task.block();\n    this.pendingTasks.delete(task.id);\n\n    return task.toPayload().ret ?? null;\n  }\n\n  private setupListeners(): void {\n    // Renderer registers a handleName (overwrites previous registration for the same handleName)\n    ipcMain.on(XPC_REGISTER, (event, payload: { handleName: string }) => {\n      const existingId = this.registry.get(payload.handleName);\n      if (existingId != null && existingId !== event.sender.id) {\n        console.log(`[xpcCenter] handler \"${payload.handleName}\" overwritten: webContentsId ${existingId} → ${event.sender.id}`);\n      }\n      this.registry.set(payload.handleName, event.sender.id);\n    });\n\n    // Renderer invokes exec via IPC\n    ipcMain.handle(XPC_EXEC, async (_event, payload: XpcPayload): Promise<any> => {\n      return this.exec(payload.handleName, payload.params);\n    });\n\n    // Target renderer finished execution, unblock pending task\n    ipcMain.on(XPC_FINISH, (_event, payload: XpcPayload) => {\n      const task = this.pendingTasks.get(payload.id);\n      if (task) {\n        task.ret = payload.ret ?? null;\n        task.unblock();\n      }\n    });\n  }\n}\n\nexport const xpcCenter = new XpcCenter();\n","/**\n * Symbol to mark methods that should not be auto-registered as xpc handlers.\n */\nexport const XPC_IGNORE = Symbol('xpc:ignore');\n\n/**\n * Decorator to mark a method as ignored for xpc handler auto-registration.\n * \n * Usage:\n * ```ts\n * class UserService extends XpcMainHandler {\n *   async getUserList(): Promise<any> { ... } // will be registered\n *   \n *   @xpcIgnore\n *   async helperMethod(): Promise<void> { ... } // will NOT be registered\n * }\n * ```\n */\nexport const xpcIgnore = (target: any, propertyKey: string): void => {\n  const descriptor = Object.getOwnPropertyDescriptor(target, propertyKey);\n  if (descriptor && typeof descriptor.value === 'function') {\n    descriptor.value[XPC_IGNORE] = true;\n  }\n};\n","import { XPC_IGNORE } from './xpc.decorator';\n\n/**\n * Prefix for all auto-registered xpc handler channels.\n * Channel format: `xpc:ClassName/methodName`\n */\nexport const XPC_HANDLER_PREFIX = 'xpc:';\n\n/**\n * Build the xpc channel name from class name and method name.\n * e.g. buildChannel('UserTable', 'getUserList') => 'xpc:UserTable/getUserList'\n */\nexport const buildXpcChannel = (className: string, methodName: string): string => {\n  return `${XPC_HANDLER_PREFIX}${className}/${methodName}`;\n};\n\n/**\n * Extract own method names from a class prototype, excluding constructor.\n * \n * Methods are ignored if:\n * 1. Name starts with `_` or `$` (private method convention)\n * 2. Marked with @xpcIgnore decorator\n */\nexport const getHandlerMethodNames = (prototype: object): string[] => {\n  const names: string[] = [];\n  const keys = Object.getOwnPropertyNames(prototype);\n  for (const key of keys) {\n    if (key === 'constructor') continue;\n    \n    // Skip methods starting with _ or $\n    if (key.startsWith('_') || key.startsWith('$')) continue;\n    \n    const descriptor = Object.getOwnPropertyDescriptor(prototype, key);\n    if (descriptor && typeof descriptor.value === 'function') {\n      // Skip methods marked with @xpcIgnore\n      if (descriptor.value[XPC_IGNORE]) continue;\n      \n      names.push(key);\n    }\n  }\n  return names;\n};\n\n/**\n * Constraint: handler methods must accept 0 or 1 parameter.\n * Methods with 2+ parameters will fail type checking.\n */\nexport type XpcHandlerMethod = (() => Promise<any>) | ((params: any) => Promise<any>);\n\n/**\n * Helper: checks if a function type has at most 1 parameter.\n * Returns the function type itself if valid, `never` otherwise.\n * Uses Parameters<> length check to avoid contravariance issues\n * where (p: any) => any extends () => any in TypeScript.\n */\ntype AssertSingleParam<F> =\n  F extends (...args: any[]) => any\n    ? Parameters<F>['length'] extends 0 | 1 ? F : never\n    : never;\n\n/**\n * Filters out keys that start with `_` or `$` (private method convention).\n */\ntype ExcludePrivateKeys<K> = K extends `_${string}` | `$${string}` ? never : K;\n\n/**\n * Utility type: extracts the method signatures from a handler class,\n * turning each method into an emitter-compatible signature.\n * Methods with 2+ parameters are mapped to `never`, causing a compile error on use.\n * Methods with `_` or `$` prefix are excluded from the emitter type.\n * Methods marked with @xpcIgnore are excluded at runtime; use `_`/`$` prefix\n * to also exclude them from the type-level emitter.\n */\nexport type XpcEmitterOf<T> = {\n  [K in keyof T as T[K] extends (...args: any[]) => any ? ExcludePrivateKeys<K> : never]:\n    AssertSingleParam<T[K]> extends never\n      ? never\n      : T[K] extends (params: infer P) => any\n        ? Parameters<T[K]>['length'] extends 0\n          ? () => Promise<any>\n          : (params: P) => Promise<any>\n        : () => Promise<any>;\n};\n","import { XpcPayload } from '../shared/xpc.type';\nimport { buildXpcChannel, getHandlerMethodNames } from '../shared/xpcHandler.type';\nimport { xpcMain } from './xpcMain.helper';\n\n/**\n * Base class for main-process xpc handlers.\n * Subclass this and define async methods — they will be auto-registered\n * as xpc handlers with channel `xpc:ClassName/methodName`.\n *\n * Methods are ignored if:\n * 1. Name starts with `_` or `$` (private method convention)\n * 2. Marked with @xpcIgnore decorator\n *\n * Example:\n * ```ts\n * // In main process — register handler:\n * class UserTable extends XpcMainHandler {\n *   async getUserList(params?: any): Promise<any> { ... } // registered\n *   \n *   async _helperMethod(): Promise<void> { ... } // NOT registered\n *   \n *   @xpcIgnore\n *   async internalMethod(): Promise<void> { ... } // NOT registered\n * }\n * const userTable = new UserTable();\n *\n * // In renderer process — call via emitter:\n * import type { UserTable } from '@main/userTable.handler';\n * const emitter = createXpcRendererEmitter<UserTable>('UserTable');\n * const list = await emitter.getUserList({ page: 1 });\n * ```\n */\nexport class XpcMainHandler {\n  constructor() {\n    const className = this.constructor.name;\n    const methodNames = getHandlerMethodNames(Object.getPrototypeOf(this));\n    for (const methodName of methodNames) {\n      const channel = buildXpcChannel(className, methodName);\n      const method = (this as any)[methodName].bind(this);\n      xpcMain.handle(channel, async (payload: XpcPayload) => {\n        return await method(payload.params);\n      });\n    }\n  }\n}\n","import { buildXpcChannel, XpcEmitterOf } from '../shared/xpcHandler.type';\nimport { xpcMain } from './xpcMain.helper';\n\n/**\n * Create a type-safe emitter proxy for a main-process xpc handler.\n * The emitter mirrors the handler's method signatures, but each call\n * sends a message via xpcMain.send() to `xpc:ClassName/methodName`.\n *\n * CRITICAL: Always use `import type` to avoid importing actual handler implementation\n * and its dependencies (e.g., sqlite, node-only modules) into the main process.\n *\n * Example:\n * ```ts\n * // In preload process:\n * class MessageTable extends XpcPreloadHandler {\n *   async getMessageList(params?: any): Promise<any> { ... }\n * }\n *\n * // In main process:\n * import type { MessageTable } from '@preload/messageTable.handler'; // ← type-only import!\n * const messageEmitter = createXpcMainEmitter<MessageTable>('MessageTable');\n * const messages = await messageEmitter.getMessageList({ chatId: '123' });\n * // sends to 'xpc:MessageTable/getMessageList'\n * ```\n */\nexport const createXpcMainEmitter = <T>(className: string): XpcEmitterOf<T> => {\n  return new Proxy({} as XpcEmitterOf<T>, {\n    get(_target, prop: string) {\n      const channel = buildXpcChannel(className, prop);\n      return (params?: any) => xpcMain.send(channel, params);\n    },\n  });\n};\n"]}