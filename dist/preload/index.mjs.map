{"version":3,"sources":["../../preload/xpc-id.helper.ts","../../preload/xpc-renderer.helper.ts"],"names":[],"mappings":";;;;;AAKA,IAAM,MAAA,GAAS,KAAK,MAAA,EAAO,CAAE,SAAS,EAAE,CAAA,CAAE,KAAA,CAAM,CAAA,EAAG,CAAC,CAAA;AACpD,IAAI,OAAA,GAAU,CAAA;AAEP,IAAM,gBAAgB,MAAc;AACzC,EAAA,OAAO,KAAK,MAAM,CAAA,CAAA,EAAA,CAAK,EAAE,OAAA,EAAS,QAAA,CAAS,EAAE,CAAC,CAAA,CAAA;AAChD,CAAA;;;ACNA,IAAM,YAAA,GAAe,kBAAA;AACrB,IAAM,QAAA,GAAW,cAAA;AACjB,IAAM,UAAA,GAAa,gBAAA;AAUnB,IAAM,cAAN,MAAkB;AAAA,EAAlB,WAAA,GAAA;AACE,IAAA,IAAA,CAAQ,QAAA,uBAAe,GAAA,EAAwB;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAO/C,MAAA,CAAO,YAAoB,OAAA,EAA2B;AACpD,IAAA,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,UAAA,EAAY,OAAO,CAAA;AAGrC,IAAA,WAAA,CAAY,IAAA,CAAK,YAAA,EAAc,EAAE,UAAA,EAAY,CAAA;AAG7C,IAAA,WAAA,CAAY,EAAA,CAAG,UAAA,EAAY,OAAO,MAAA,EAAQ,OAAA,KAAwB;AAChE,MAAA,IAAI,GAAA,GAAW,IAAA;AACf,MAAA,MAAM,YAAA,GAAe,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,UAAU,CAAA;AACjD,MAAA,IAAI,YAAA,EAAc;AAChB,QAAA,IAAI;AACF,UAAA,GAAA,GAAM,MAAM,aAAa,OAAO,CAAA;AAAA,QAClC,SAAS,EAAA,EAAI;AACX,UAAA,GAAA,GAAM,IAAA;AAAA,QACR;AAAA,MACF;AAEA,MAAA,WAAA,CAAY,KAAK,UAAA,EAAY;AAAA,QAC3B,IAAI,OAAA,CAAQ,EAAA;AAAA,QACZ,YAAY,OAAA,CAAQ,UAAA;AAAA,QACpB,QAAQ,OAAA,CAAQ,MAAA;AAAA,QAChB;AAAA,OACa,CAAA;AAAA,IACjB,CAAC,CAAA;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa,UAAA,EAA0B;AACrC,IAAA,IAAA,CAAK,QAAA,CAAS,OAAO,UAAU,CAAA;AAC/B,IAAA,WAAA,CAAY,mBAAmB,UAAU,CAAA;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,IAAA,CAAK,UAAA,EAAoB,MAAA,EAA4B;AACzD,IAAA,MAAM,OAAA,GAAsB;AAAA,MAC1B,IAAI,aAAA,EAAc;AAAA,MAClB,UAAA;AAAA,MACA,MAAA;AAAA,MACA,GAAA,EAAK;AAAA,KACP;AAEA,IAAA,OAAO,MAAM,WAAA,CAAY,MAAA,CAAO,QAAA,EAAU,OAAO,CAAA;AAAA,EACnD;AACF,CAAA;AAEO,IAAM,WAAA,GAAc,IAAI,WAAA;AAYxB,IAAM,oBAAoB,MAAsB;AACrD,EAAA,OAAO;AAAA,IACL,MAAA,EAAQ,CAAC,UAAA,EAAoB,OAAA,KAAyD;AACpF,MAAA,WAAA,CAAY,MAAA,CAAO,YAAY,OAAO,CAAA;AAAA,IACxC,CAAA;AAAA,IACA,YAAA,EAAc,CAAC,UAAA,KAA6B;AAC1C,MAAA,WAAA,CAAY,aAAa,UAAU,CAAA;AAAA,IACrC,CAAA;AAAA,IACA,IAAA,EAAM,CAAC,UAAA,EAAoB,MAAA,KAA+B;AACxD,MAAA,OAAO,WAAA,CAAY,IAAA,CAAK,UAAA,EAAY,MAAM,CAAA;AAAA,IAC5C;AAAA,GACF;AACF","file":"index.mjs","sourcesContent":["/**\n * High-performance process-unique ID generator for renderer process.\n * Combines a random prefix (per process) with an incrementing counter.\n * Guaranteed unique within a single process lifetime.\n */\nconst prefix = Math.random().toString(36).slice(2, 8);\nlet counter = 0;\n\nexport const generateXpcId = (): string => {\n  return `r-${prefix}-${(++counter).toString(36)}`;\n};\n","import { ipcRenderer } from 'electron';\nimport { XpcPayload } from '../shared/xpc.type';\nimport { generateXpcId } from './xpc-id.helper';\n\nconst XPC_REGISTER = '__xpc_register__';\nconst XPC_EXEC = '__xpc_exec__';\nconst XPC_FINISH = '__xpc_finish__';\n\ntype XpcHandler = (payload: XpcPayload) => Promise<any>;\n\n/**\n * XpcRenderer: runs in the renderer process (via preload).\n * - register({handleName}): registers a handleName with main process, also sets up local listener\n * - handle(handleName, handler): registers handler locally + sends __xpc_register__ to main\n * - send(handleName, params): invokes __xpc_exec__ on main, awaits result via ipcRenderer.invoke\n */\nclass XpcRenderer {\n  private handlers = new Map<string, XpcHandler>();\n\n  /**\n   * Register a handleName with the main process and bind a local async handler.\n   * When another renderer calls send() with this handleName, xpcCenter will forward\n   * the payload to this renderer, the handler executes, and result is sent back via __xpc_finish__.\n   */\n  handle(handleName: string, handler: XpcHandler): void {\n    this.handlers.set(handleName, handler);\n\n    // Notify main process about this registration\n    ipcRenderer.send(XPC_REGISTER, { handleName });\n\n    // Listen for incoming handleName events forwarded by xpcCenter\n    ipcRenderer.on(handleName, async (_event, payload: XpcPayload) => {\n      let ret: any = null;\n      const localHandler = this.handlers.get(handleName);\n      if (localHandler) {\n        try {\n          ret = await localHandler(payload);\n        } catch (_e) {\n          ret = null;\n        }\n      }\n      // Send __xpc_finish__ back to main with result\n      ipcRenderer.send(XPC_FINISH, {\n        id: payload.id,\n        handleName: payload.handleName,\n        params: payload.params,\n        ret,\n      } as XpcPayload);\n    });\n  }\n\n  /**\n   * Remove a registered handler.\n   */\n  removeHandle(handleName: string): void {\n    this.handlers.delete(handleName);\n    ipcRenderer.removeAllListeners(handleName);\n  }\n\n  /**\n   * Send a message to another renderer (or any registered handler) via main process.\n   * Uses ipcRenderer.invoke(__xpc_exec__) which blocks until the target finishes.\n   * Returns the ret value from the target handler, or null.\n   */\n  async send(handleName: string, params?: any): Promise<any> {\n    const payload: XpcPayload = {\n      id: generateXpcId(),\n      handleName,\n      params,\n      ret: null,\n    };\n\n    return await ipcRenderer.invoke(XPC_EXEC, payload);\n  }\n}\n\nexport const xpcRenderer = new XpcRenderer();\n\nexport type XpcRendererApi = {\n  handle: (handleName: string, handler: (payload: XpcPayload) => Promise<any>) => void;\n  removeHandle: (handleName: string) => void;\n  send: (handleName: string, params?: any) => Promise<any>;\n};\n\n/**\n * Returns a contextBridge-safe object for exposeInMainWorld.\n * Usage: contextBridge.exposeInMainWorld('xpcRenderer', exposeXpcRenderer())\n */\nexport const exposeXpcRenderer = (): XpcRendererApi => {\n  return {\n    handle: (handleName: string, handler: (payload: XpcPayload) => Promise<any>): void => {\n      xpcRenderer.handle(handleName, handler);\n    },\n    removeHandle: (handleName: string): void => {\n      xpcRenderer.removeHandle(handleName);\n    },\n    send: (handleName: string, params?: any): Promise<any> => {\n      return xpcRenderer.send(handleName, params);\n    },\n  };\n};\n"]}