{"version":3,"sources":["../../src/preload/xpcId.helper.ts","../../src/preload/xpcPreload.helper.ts","../../src/shared/xpcHandler.type.ts","../../src/preload/xpcPreload.handler.ts","../../src/preload/xpcPreload.emitter.ts"],"names":["ipcRenderer","contextBridge"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * High-performance process-unique ID generator for renderer process.\n * Combines a random prefix (per process) with an incrementing counter.\n * Guaranteed unique within a single process lifetime.\n */\nconst prefix = Math.random().toString(36).slice(2, 8);\nlet counter = 0;\n\nexport const generateXpcId = (): string => {\n  return `r-${prefix}-${(++counter).toString(36)}`;\n};\n","import { contextBridge, ipcRenderer } from 'electron';\nimport { XpcPayload, XpcRendererApi } from '../shared/xpc.type';\nimport { generateXpcId } from './xpcId.helper';\n\nconst XPC_REGISTER = '__xpc_register__';\nconst XPC_EXEC = '__xpc_exec__';\nconst XPC_FINISH = '__xpc_finish__';\n\ntype XpcHandler = (payload: XpcPayload) => Promise<any>;\n\n/** Global handlers map, extracted from XpcRenderer class */\nexport const xpcHandlers = new Map<string, XpcHandler>();\n\nexport type { XpcRendererApi } from '../shared/xpc.type';\n\n/**\n * Register a handleName with the main process and bind a local async handler.\n * When another renderer calls send() with this handleName, xpcCenter will forward\n * the payload to this renderer, the handler executes, and result is sent back via __xpc_finish__.\n */\nconst handle = (handleName: string, handler: XpcHandler): void => {\n  // Remove existing listener to prevent stacking when the same handleName is re-registered\n  if (xpcHandlers.has(handleName)) {\n    ipcRenderer.removeAllListeners(handleName);\n  }\n\n  xpcHandlers.set(handleName, handler);\n\n  // Notify main process about this registration\n  ipcRenderer.send(XPC_REGISTER, { handleName });\n\n  // Listen for incoming handleName events forwarded by xpcCenter\n  ipcRenderer.on(handleName, async (_event, payload: XpcPayload) => {\n    let ret: any = null;\n    const localHandler = xpcHandlers.get(handleName);\n    if (localHandler) {\n      try {\n        ret = await localHandler(payload);\n      } catch (_e) {\n        ret = null;\n      }\n    }\n    // Send __xpc_finish__ back to main with result\n    ipcRenderer.send(XPC_FINISH, {\n      id: payload.id,\n      handleName: payload.handleName,\n      params: payload.params,\n      ret,\n    } as XpcPayload);\n  });\n};\n\n/**\n * Remove a registered handler.\n */\nconst removeHandle = (handleName: string): void => {\n  xpcHandlers.delete(handleName);\n  ipcRenderer.removeAllListeners(handleName);\n};\n\n/**\n * Send a message to another renderer (or any registered handler) via main process.\n * Uses ipcRenderer.invoke(__xpc_exec__) which blocks until the target finishes.\n * Returns the ret value from the target handler, or null.\n */\nconst send = async (handleName: string, params?: any): Promise<any> => {\n  const payload: XpcPayload = {\n    id: generateXpcId(),\n    handleName,\n    params,\n    ret: null,\n  };\n\n  return await ipcRenderer.invoke(XPC_EXEC, payload);\n};\n\n/**\n * Returns a contextBridge-safe object for exposeInMainWorld.\n */\nconst createXpcRendererApi = (): XpcRendererApi => {\n  return {\n    handle: (handleName: string, handler: (payload: XpcPayload) => Promise<any>): void => {\n      handle(handleName, handler);\n    },\n    removeHandle: (handleName: string): void => {\n      removeHandle(handleName);\n    },\n    send: (handleName: string, params?: any): Promise<any> => {\n      return send(handleName, params);\n    },\n  };\n};\n\n/** The xpcRenderer API instance */\nexport const xpcRenderer: XpcRendererApi = createXpcRendererApi();\n\n// Auto-expose xpcRenderer to window on import\nif (process.contextIsolated) {\n  try {\n    contextBridge.exposeInMainWorld('xpcRenderer', xpcRenderer);\n  } catch (error) {\n    console.error('[xpcPreload] exposeInMainWorld failed:', error);\n  }\n} else {\n  (globalThis as any).xpcRenderer = xpcRenderer;\n}\n","/**\n * Prefix for all auto-registered xpc handler channels.\n * Channel format: `xpc:ClassName/methodName`\n */\nexport const XPC_HANDLER_PREFIX = 'xpc:';\n\n/**\n * Build the xpc channel name from class name and method name.\n * e.g. buildChannel('UserTable', 'getUserList') => 'xpc:UserTable/getUserList'\n */\nexport const buildXpcChannel = (className: string, methodName: string): string => {\n  return `${XPC_HANDLER_PREFIX}${className}/${methodName}`;\n};\n\n/**\n * Extract own method names from a class prototype, excluding constructor.\n */\nexport const getHandlerMethodNames = (prototype: object): string[] => {\n  const names: string[] = [];\n  const keys = Object.getOwnPropertyNames(prototype);\n  for (const key of keys) {\n    if (key === 'constructor') continue;\n    const descriptor = Object.getOwnPropertyDescriptor(prototype, key);\n    if (descriptor && typeof descriptor.value === 'function') {\n      names.push(key);\n    }\n  }\n  return names;\n};\n\n/**\n * Constraint: handler methods must accept 0 or 1 parameter.\n * Methods with 2+ parameters will fail type checking.\n */\nexport type XpcHandlerMethod = (() => Promise<any>) | ((params: any) => Promise<any>);\n\n/**\n * Helper: checks if a function type has at most 1 parameter.\n * Returns the function type itself if valid, `never` otherwise.\n * Uses Parameters<> length check to avoid contravariance issues\n * where (p: any) => any extends () => any in TypeScript.\n */\ntype AssertSingleParam<F> =\n  F extends (...args: any[]) => any\n    ? Parameters<F>['length'] extends 0 | 1 ? F : never\n    : never;\n\n/**\n * Utility type: extracts the method signatures from a handler class,\n * turning each method into an emitter-compatible signature.\n * Methods with 2+ parameters are mapped to `never`, causing a compile error on use.\n */\nexport type XpcEmitterOf<T> = {\n  [K in keyof T as T[K] extends (...args: any[]) => any ? K : never]:\n    AssertSingleParam<T[K]> extends never\n      ? never\n      : T[K] extends (params: infer P) => any\n        ? Parameters<T[K]>['length'] extends 0\n          ? () => Promise<any>\n          : (params: P) => Promise<any>\n        : () => Promise<any>;\n};\n","import { XpcPayload } from '../shared/xpc.type';\nimport { buildXpcChannel, getHandlerMethodNames } from '../shared/xpcHandler.type';\nimport { xpcRenderer } from './xpcPreload.helper';\n\n/**\n * Base class for preload-process xpc handlers.\n * Subclass this and define async methods â€” they will be auto-registered\n * as xpc handlers with channel `xpc:ClassName/methodName`.\n *\n * Example:\n * ```ts\n * class UserTable extends XpcPreloadHandler {\n *   async getUserList(params?: any): Promise<any> { ... }\n * }\n * const userTable = new UserTable();\n * // auto-registers handler for 'xpc:UserTable/getUserList'\n * ```\n */\nexport class XpcPreloadHandler {\n  constructor() {\n    const className = this.constructor.name;\n    const methodNames = getHandlerMethodNames(Object.getPrototypeOf(this));\n    for (const methodName of methodNames) {\n      const channel = buildXpcChannel(className, methodName);\n      const method = (this as any)[methodName].bind(this);\n      xpcRenderer.handle(channel, async (payload: XpcPayload) => {\n        return await method(payload.params);\n      });\n    }\n  }\n}\n","import { buildXpcChannel, XpcEmitterOf } from '../shared/xpcHandler.type';\nimport { xpcRenderer } from './xpcPreload.helper';\n\n/**\n * Create a type-safe emitter proxy for a preload-process xpc handler.\n * The emitter mirrors the handler's method signatures, but each call\n * sends a message via xpcRenderer.send() to `xpc:ClassName/methodName`.\n *\n * Example:\n * ```ts\n * class UserTable extends XpcPreloadHandler {\n *   async getUserList(params?: any): Promise<any> { ... }\n * }\n * const userTableEmitter = createXpcPreloadEmitter<UserTable>('UserTable');\n * const list = await userTableEmitter.getUserList({ page: 1 });\n * // sends to 'xpc:UserTable/getUserList'\n * ```\n */\nexport const createXpcPreloadEmitter = <T>(className: string): XpcEmitterOf<T> => {\n  return new Proxy({} as XpcEmitterOf<T>, {\n    get(_target, prop: string) {\n      const channel = buildXpcChannel(className, prop);\n      return (params?: any) => xpcRenderer.send(channel, params);\n    },\n  });\n};\n"]}